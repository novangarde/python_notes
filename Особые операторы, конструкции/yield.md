
Ключевое слово **`yield`** в Python используется для создания генераторов, которые позволяют возвращать значения по одному, сохраняя состояние функции между вызовами. Это позволяет эффективно работать с большими объемами данных, не загружая их полностью в память.

## Как работает генератор с `yield`

Когда вы используете `yield` внутри функции, она становится функцией-генератором. Вот основные моменты о том, как это работает:

1. **Сохранение состояния:**
    
    - Когда функция-генератор вызывается, выполнение начинается с первой строки функции. Когда интерпретатор встречает `yield`, он возвращает значение вызывающему коду и "замораживает" текущее состояние функции, включая все локальные переменные.
    - При следующем вызове генератора выполнение продолжается с той строки, где было остановлено, и продолжает до следующего `yield` или до завершения функции.
    
2. **Итерация:**- Генераторы могут быть использованы в циклах `for`, что позволяет легко перебрать значения, которые они генерируют. Например:

`result = make_list(filepath)

`def make_list(filepath):
	`with open(filepath, 'r', encoding='utf-8') as file:
		`for line in file:
			`yield line  # Возвращаем одну строку за раз`

В переменной `result` сохранится список, и каждая строка, отправленная командой `yield`, будет добавлена к списку, как если бы использовали `append()`.

3. **Память и производительность:**
    
    - Использование генераторов позволяет экономить память, так как они не требуют хранения всех значений в памяти одновременно. Это особенно полезно при работе с большими файлами или потоками данных.
    

## Пример использования

Вот пример функции-генератора, которая возвращает четные числа из списка:

`def get_even(numbers):
	`for number in numbers:
		`if number % 2 == 0:
		`yield number  # Возвращаем четное число
		
`# Использование генератора
`for even_number in get_even([1, 2, 3, 4, 5, 6]):
	`print(even_number)  # Вывод: 2, 4, 6`

## Преимущества использования `yield`

- **Эффективность:** Генераторы позволяют обрабатывать данные по одному элементу за раз, что снижает использование памяти.
- **Удобство:** Генераторы упрощают код для обработки последовательностей данных и позволяют легко создавать итераторы.
- **Логика:** С помощью `yield` можно реализовать сложные логические структуры без необходимости создания дополнительных классов или функций.