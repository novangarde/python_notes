
Аналог блока try-catch, служит для отлавливания **исключений** (ошибок).

Исключения в Python — это события, которые возникают во время выполнения программы и прерывают ее нормальный ход. Они служат для сигнализации о возникновении ошибок, таких как неправильные операции, недопустимые значения или ошибки в логике программы. Когда Python сталкивается с ситуацией, которую не может обработать, он генерирует исключение, и выполнение программы останавливается.

Когда возникает исключение, выполнение программы останавливается, и управление передается ближайшему обработчику исключений (`except` блок). Если обработчик не найден, программа завершится с ошибкой.

Базовый синтаксис:
```Python
try:
	# код, который может вызвать исключение
except ExceptionType:
	# код, который выполняется при возникновении исключения
```

## try

В блоке `try` прописываются функции и операции, которые нужно выполнить. Если внутри блока будет сгенерировано исключение, оно обработается в блоке `except`

```Python
try:
	with open('data.csv', 'r') as file:
		content = file.read()
		print(content)
except Exception as e:
	print(f"Произошла ошибка: {e}")
```

## except

В блоке `except` прописываются действия, которые нужно исполнить, если блок `try` поймал какое-то исключение - к примеру, вывести в консоль текст об ошибке, как в примере выше.

Можно вписать туда сразу несколько типов исключений:

```Python
except (ValueError, ZeroDivisionError) as e:
	print(f"Ошибка: {e}")
```

Если хочется обработать  все возможные исключения, можно использовать общий блок `except` без указания типа. К сожалению, такой подход ловит абсолютно все исключения, включая системные и прерывания, такой подход ==не рекомендуется==:

```Python
try:
	print(1 / 0)  # Это вызовет ZeroDivisionError
except:
	print("Произошла ошибка.")`
```

Лучше использовать except Exception:, потому что такой блок ловит только исключения, производные от класса `Exception`, что включает большинство стандартных ошибок, но исключает системные исключения (например, `SystemExit`, `KeyboardInterrupt` и т.д.).

Это более безопасный способ обработки ошибок, поскольку он позволяет избежать перехвата критических системных ошибок и дает возможность лучше управлять поведением программы при возникновении исключений:

```Python
try:
	print(1 / 0)  # Это вызовет ZeroDivisionError
except Exception:
	print("Произошла ошибка.")`
```

**Иерархия исключений**: Исключения в Python имеют иерархическую структуру. Например, `ValueError` является подклассом базового класса `Exception`. Поэтому если вы укажете более общий класс (например, `Exception`) перед более узким (например, `ValueError`), то обработка будет происходить только в первом блоке.

**Порядок обработки**: Рекомендуется сначала обрабатывать более специфические исключения, а затем более общие. Например:

```Python
try:
	# код
except ValueError:
	# обработка ValueError
except Exception:
	# обработка всех остальных исключений
```

## raise

Если хочется как-то конкретизировать суть исключения, можно описать его внутри функции при помощи raise:

```Python
def main:
	if (2 == 3):
		print("2 равно 3")
	else:
		raise ValueError("2 не равно 3.")

if __name__ == '__main__':
	try:
		main()
	except ValueError as e:
		print(e) # выведет "2 не равно 3"
```

При помощи `raise` мы можем вызывать любой из типов исключений, включая пользовательские. То есть, raise помогают нам указать в нужном месте детальную информацию о том, какое именно исключение произошло.

## Типы исключений

`ValueError()`
`TypeError()`
`ZeroDivisionError()`
`IndexError

Типы исключений указываются после except, чтобы явно указать, какой именно тип ошибок нужно отловить в этом блоке. Можно использовать несколько except подряд, для каждой ошибки, либо использовать класс `Exception`, который отлавливает все ошибки.
