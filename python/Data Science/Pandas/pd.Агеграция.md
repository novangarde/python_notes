
## df.groupby()

Позволяет группировать данные по одному или нескольким столбцам и выполнять агрегационные операции над этими группами. Это особенно полезно для анализа данных, когда нужно изучить различные аспекты данных или сделать сводные выводы на основе группировки.

После группировки можно применять различные агрегационные функции к каждой группе, такие как:

- `mean()`: Среднее значение.
- `median()`: Медиана.
- `sum()`: Сумма.
- `count()`: Количество элементов.
- `min()` и `max()`: Минимальное и максимальное значения.

### Группировка по одному столбцу

```Python
df.groupby('Make')['Fines'].median()

# Группируем по столбцу 'Make'
# Находим медиану из значений колонки 'Fines'
```

### Группировка по двум столбцам

```Python
df.groupby(['Make', 'Model'])['Fines'].median()

# Группируем по столбцам 'Make' и 'Model'
# Находим медиану из значений колонки 'Fines'
```

### Подсчет количества значений в группировке

```Python
df.groupby(['Make', 'Model'])['Fines'].count()

# Группируем по столбцам 'Make' и 'Model'
# Находим количество значений колонки 'Fines'
```

### Рассчитываем стандартное отклонение

```Python
df.groupby(['Make', 'Model'])['Fines'].std()

# Группируем по столбцам 'Make' и 'Model'
# Находим дисперсию значений колонки 'Fines'
```

### df.agg()

Используется для применения агрегирующих функций к данным. Он позволяет вычислять сводные значения, такие как сумма (`sum`), среднее (`mean`), медиана (`median`), количество элементов (`count`) и другие, для групп данных или отдельных столбцов DataFrame.

```Python
df.groupby(['Make', 'Model'])['Fines'].agg(['min', 'max'])

# Группируем по столбцам 'Make' и 'Model'
# Находим минимальные и максимальные значения колонки 'Fines' благодаря аггрегированной функции.
```

### df.count()

Используется для подсчета количества не пропущенных значений в каждом столбце DataFrame. Он игнорирует пропущенные значения

```Python
df.count()
# выводит количество значений в каждом столбце
```

### df.value_counts()

Используется для подсчета частоты каждого уникального значения в Series или столбце DataFrame. Он возвращает Series, где индексами являются уникальные значения из исходных данных, а значениями — количество раз, когда каждое из этих значений встречается.По умолчанию результаты сортируются по убыванию частоты (самые часто встречающиеся значения первыми). Пропущенные значения исключаются из результата по умолчанию.

```Python
df["column"].value_counts()
# Возвращает уникальные значения из колонки "column" с количеством их вхождений
```

## df.corr()

Вычисляет попарную корреляцию между столбцами DataFrame. По умолчанию он использует коэффициент корреляции Пирсона, который является мерой линейной зависимости между двумя переменными.

## Основные моменты о `df.corr()`:

1. **Методы корреляции**:
    
    - **'pearson'**: Стандартный коэффициент корреляции Пирсона.
    - **'kendall'**: Коэффициент корреляции тау Кендалла.
    - **'spearman'**: Ранговая корреляция Спирмена.
    
2. **Параметры**:
    
    - `method`: Выбор метода для расчета корреляции (по умолчанию `'pearson'`).
    - `min_periods`: Минимальное количество наблюдений для пары столбцов (по умолчанию 1).
    - `numeric_only`: Включать только числовые данные (по умолчанию False).
    
3. **Результат**:  
    Возвращает матрицу корреляций между всеми парами числовых столбцов DataFrame.

```Python
import pandas as pd

data = {
    "Duration": [50, 40, 45],
    "Pulse": [109, 117, 110],
    "Calories": [409.1, 479.5, 340.8]
}

df = pd.DataFrame(data)
print(df.corr())

```

Этот код вычислит и напечатает матрицу попарных коэффициентов Пирсона для всех столбцов в DataFrame.

Если вам нужно рассчитать коэффициент корреляции только между двумя конкретными столбцами (`col1` и `col2`), то можно сделать это так:

```Python
correlation_coefficient = df['col1'].corr(df['col2'])
print(correlation_coefficient)
```

## df.unstack()

Метод `unstack()` в pandas используется для перестановки данных в DataFrame или Series. Он берет уровень индекса (строк) и "поворачивает" его в столбцы, создавая новый уровень меток столбцов. Это делает его обратной операцией к методу `stack()`, который делает противоположное — превращает уровень столбцов в уровень индекса.

==Если в столбце есть несколько категориальных вариантов, применяем к нему unstack(), и из этого столбца появляется по столбцу для каждой из категорий==

> ==**Важно:**== работает только со сгруппированными данными!

То есть, к примеру, у нас есть следующая группировка:

```Python
result = checker.groupby(['date', 'daytime']).size()
```

Она дает нам следующие данные:

```Python
date        daytime
2024-03-01  morning    5
            afternoon  3
            evening    2
2024-03-02  morning    4
            afternoon  2
            evening    1
```

Здесь информация сгруппирована по двум столбцам и подсчитано количество всех их сочетаний. Применим unstack():

```Python
result_unstacked = result.unstack('daytime')
```

Получим результат:

```Python
daytime  morning  afternoon  evening
date                                     
2024-03-01         5           3         2
2024-03-02         4           2         1
```

